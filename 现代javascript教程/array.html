<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        li{
            box-shadow: 1px 1px 1px rgba(red, green, blue, alpha);
        }
    </style>
</head>
<body>
    <ul>
        <li>我是猪</li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <script>
        // 请注意，sort，reverse 和 splice 方法修改的是数组本身。
        function camlize(str){
            let arr= str.split('-');
            arr=arr.map(function(item,index){
            return index==0?item:item.slice(0,1).toUpperCase() + item.slice(1)
                });
            return arr.join('');
        }
        function filterRange(arr, a, b){
            return arr.filter(item => item>a && item<b );
        }
        function Calculator(){
            this.methods={
                "+":(a,b) => a+b,
                "-":(a,b) => a-b,

            };
            this.calculate= function(str){

                let arr=str.split(' ');
                if(arr.length!=3){
                    return
                }
                let a=arr[0]
                    ,op=arr[1]
                    ,b=arr[2];
                return this.methods[op](a,b)
            };
            this.addMethod=function(name,func){
                this.methods[name]=func
            };
        }
        console.log(camlize("background-color"));
        console.log(camlize("list-style-image"));
        console.log("*".repeat(20));
        console.log(filterRange([5, 3, 8, 1,2,2,3],1,4));
        console.log("*".repeat(20));
        let powerCalc = new Calculator;
        powerCalc.addMethod("*", (a, b) => a * b);
        powerCalc.addMethod("/", (a, b) => a / b);
        powerCalc.addMethod("**", (a, b) => a ** b);

        let result = powerCalc.calculate("2 / 3");
        console.log( result ); // 8

        console.log("*".repeat(20));
        let john = { name: "John", age: 25 };
        let pete = { name: "Pete", age: 30 };
        let mary = { name: "Mary", age: 28 };

        let users = [ john, pete, mary ];

        let names = users.map((item,index,array)=>{item[name]}) /* ... your code */

       console.log( names ); // Joh n, Pete, Mary
       console.log("*".repeat(40));
       function inBetween(a, b){
            return function (item){
              return  item>=a && item<=b;
            }
       }
       arr=[1,2,3,4,5,6]
       console.log( arr.filter(inBetween(3, 6)) ); // 3,4,5,6

       function sum(a){
           let currentsum=a
            function f(b){
                currentsum+=b
                return f;
            }
            f.toString=function(){
                return currentsum;
            }; //对象到原始值的转换
            return f;
       }
        console.log(sum(1)(2) == 3); // 1 + 2
        // sum(1)(2)(3) == 6; // 1 + 2 + 3
        console.log("*".repeat(60));
        let worker = {
            someMethod() {
                return 1;
            },

            slow(x) {
                console.log("Called with " + x);
                console.log(this)
                return x * this.someMethod(); // (*)
            }
        };

        function cachingDecorator(func) {
            let cache = new Map();
            console.log(this) //windows
            return function(x) {
                console.log(this)  //worker对象
                if (cache.has(x)) {
                    return cache.get(x);
                }
                let result = func.call(this, x); // 现在 "this" 被正确地传递了 因为上层匿名函数被赋值给worker对象，所以这个里面的this就是worker。
                // let result = func(x); // func出现undefinde 为什么但是func本身=原来的slow被赋值，不能找到this了
                cache.set(x, result);
                return result;
            };
        }

        worker.slow = cachingDecorator(worker.slow); // 现在对其进行缓存

        console.log( worker.slow(2) ); // 工作正常
    // console.log( worker.slow(2) ); // 工作正常，没有调用原始函数（使用的缓存）
    // 间谍装饰器
    function work(a, b) {
         console.log( a + b ); // work 是一个任意的函数或方法
    }

   
    function spy(func){
        function wrap(...args){
            // wrap.calls=[];
            wrap.calls.push(args)
            func(...args)
            // func.apply(this,args)
        }
        wrap.calls=[];
        return wrap;
    }
    work = spy(work);
    work(1, 2); // 3
    work(4, 5); // 9

    for (let args of work.calls) {
        console.log( 'call:' + args.join() ); // "call:1,2", "call:4,5"
    }
    console.log("*".repeat(80));
    function test1(){
        console.log(this);
        function test2(){
            console.log(this);
        }
        test2();//普通函数，不是看定义在哪里，看谁调用 ，所以依然是windows
    }
    let user={name:'xulei',age:15}
    test1.call(user);
    console.log("*".repeat(100));
    s=function Rabbit(){};
    console.log(s.prototype)
    console.log(JSON.stringify(Object.getOwnPropertyDescriptor(s.prototype,'constructor'),null,2))

    for (let x in s.prototype){
        console.log(x);
    }

    function Rabbit1() {}
    Rabbit1.prototype = {
    eats: true
    };
//     F.prototype 属性（不要把它与 [[Prototype]] 弄混了）在 new F 被调用时为新对象的 [[Prototype]] 赋值。
// F.prototype 的值要么是一个对象，要么就是 null：其他值都不起作用。
// "prototype" 属性仅在设置了一个构造函数（constructor function），并通过 new 调用时，才具有这种特殊的影响。
    let rabbit1 = new Rabbit1();
    console.log(rabbit1.__proto__)
    Rabbit1.prototype = {};  
    console.log(rabbit1.__proto__==Rabbit1.prototype)//指向同一个对象
    Rabbit1.prototype = {};  
    console.log( rabbit1.eats ); // true

    let dictionary = Object.create(null);

    // 你的添加 dictionary.toString 方法的代码
    dictionary.toString=function(){

    };
    // 添加一些数据
    dictionary.apple = "Apple";
    dictionary.__proto__ = "test"; // 这里 __proto__ 是一个常规的属性键

    // 在循环中只有 apple 和 __proto__
    for(let key in dictionary) {
    console.log(key); // "apple", then "__proto__"
    }

    // 你的 toString 方法在发挥作用
    console.log(dictionary); // "apple,__proto__"

    // __proto__ 不是一个对象的属性，只是 Object.prototype 的访问器属性：
    let obj = {};

    let key = prompt("What's the key?", "__proto__");
    obj[key] = "some value";

    console.log(obj[key]); // [object Object]，并不是 "some value"！

    function Rabbit(name) {
    this.name = name;
    }
    Rabbit.prototype.sayHi = function() {
    console.log(this.name);
    };
    console.log("*".repeat(100));
    let rabbit = new Rabbit("Rabbit");

    rabbit.sayHi(); //Rabbit
    Rabbit.prototype.sayHi();//undefined
    Object.getPrototypeOf(rabbit).sayHi(); //undefined
    rabbit.__proto__.sayHi(); //undefined
    </script>
</body>
</html>